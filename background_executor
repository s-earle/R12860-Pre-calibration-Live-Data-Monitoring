#!/usr/bin/env python3
"""
Background executor script for auto-running commands on Spartan HPC
This script keeps running and waits for commands
"""

import subprocess
import time
import json
import os
from datetime import datetime

CONFIG_FILE = "executor_config.json"
STATUS_FILE = "executor_status.json"

def load_config():
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except:
            return None
    return None

def save_status(status_data):
    """Save current status to file"""
    with open(STATUS_FILE, 'w') as f:
        json.dump(status_data, f, indent=2)

# def sync_from_spartan(remote_host, remote_dir, local_dir="plots/", serial_number=None):
#     """Execute rsync command to sync files from structured directory"""
#     try:
#         # Find the most recent scan_output directory
#         find_command = (
#             f"ssh {remote_host} "
#             f"'ls -td {remote_dir}/scan_output_* 2>/dev/null | head -n 1'"
#         )
        
#         find_result = subprocess.run(
#             find_command,
#             shell=True,
#             capture_output=True,
#             text=True,
#             timeout=30
#         )
        
#         latest_scan_dir = find_result.stdout.strip()
        
#         if not latest_scan_dir:
#             return True, "No scan_output directories found"
        
#         # If serial number provided, sync only that SN's directory
#         if serial_number:
#             source_path = f"{latest_scan_dir}/{serial_number}/"
#         else:
#             source_path = f"{latest_scan_dir}/"
        
#         # Sync all files from the latest scan directory structure
#         # Updated to match new filenames: *_charge.png and *_GAIN.txt
#         rsync_command = (
#             f"rsync -avz --include='*/' "
#             f"--include='*_charge.png' "
#             f"--include='*_GAIN.txt' "
#             f"--exclude='*' "
#             f"{remote_host}:{source_path} {local_dir}"
#         )
        
#         result = subprocess.run(
#             rsync_command,
#             shell=True,
#             capture_output=True,
#             text=True,
#             timeout=120
#         )
        
#         if result.returncode == 0:
#             scan_name = os.path.basename(latest_scan_dir)
#             sn_msg = f" (SN: {serial_number})" if serial_number else ""
#             return True, f"Synced from {scan_name}{sn_msg}"
#         else:
#             return False, f"Rsync failed with code {result.returncode}"
        
#     except Exception as e:
#         return False, f"Sync error: {str(e)}"

def sync_from_spartan(remote_host, remote_dir, local_dir="plots/", serial_number=None):
    """Execute rsync command to sync files from scan_output directories"""
    try:
        # If serial number provided, sync only that SN's directory from all scan_output dirs
        if serial_number:
            source_path = f"{remote_dir}/scan_output_*/{serial_number}/"
        else:
            source_path = f"{remote_dir}/scan_output_*/"
        
        # Sync all files from scan_output directories
        # Updated to match new filenames: *_charge.png and *_GAIN.txt
        rsync_command = (
            f"rsync -avz --include='*/' "
            f"--include='scan_output_*/' "
            f"--include='*_charge.png' "
            f"--include='*_GAIN.txt' "
            f"--exclude='*' "
            f"{remote_host}:{source_path} {local_dir}"
        )
        
        result = subprocess.run(
            rsync_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode == 0:
            sn_msg = f" (SN: {serial_number})" if serial_number else ""
            return True, f"Synced from scan_output_*{sn_msg}"
        else:
            return False, f"Rsync failed with code {result.returncode}"
        
    except Exception as e:
        return False, f"Sync error: {str(e)}"


def execute_command(remote_host, remote_dir, remote_command, serial_number=None):
    """Execute command on remote server"""
    # Replace {SN} placeholder with actual serial number
    if serial_number and '{SN}' in remote_command:
        actual_command = remote_command.replace('{SN}', serial_number)
    else:
        actual_command = remote_command
    
    ssh_command = (
        f"ssh {remote_host} "
        f"'cd {remote_dir} && {actual_command}'"
    )
    
    try:
        result = subprocess.run(
            ssh_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        return result.returncode == 0, result.stdout, result.stderr
    except Exception as e:
        return False, "", str(e)

def main():
    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Background executor started")
    print("Waiting for commands...")
    
    # Initialize status as idle
    save_status({
        'running': False,
        'completed': 0,
        'total': 0,
        'message': 'Executor ready, waiting for commands'
    })
    
    while True:
        try:
            config = load_config()
            
            if config and config.get('running'):
                print(f"\n[{datetime.now().strftime('%H:%M:%S')}] Starting live monitoring")
                
                # Update status
                save_status({
                    'running': True,
                    'completed': 0,
                    'total': config['total_runs'],
                    'message': 'Starting SLURM job on server'
                })
                
                # Execute the SLURM job ONCE - it will handle all 21 points
                print("  Submitting SLURM job...")
                exec_success, stdout, stderr = execute_command(
                    config['remote_host'],
                    config['remote_directory'],
                    config['remote_command'],
                    serial_number=config.get('serial_number')
                )
                
                if exec_success:
                    print(f"  ✓ SLURM job submitted successfully")
                    if stdout:
                        print(f"  Job ID: {stdout.strip()}")
                else:
                    print(f"  ✗ SLURM job submission failed")
                    if stderr:
                        print(f"  Error: {stderr[:200]}")
                
                # Now just sync periodically while the job runs
                wait_time = config.get('interval_seconds', 60)
                
                for run_num in range(1, config['total_runs'] + 1):
                    # Check if we should stop
                    config = load_config()
                    if not config or not config.get('running'):
                        print(f"[{datetime.now().strftime('%H:%M:%S')}] Monitoring stopped by user")
                        save_status({
                            'running': False,
                            'completed': run_num - 1,
                            'total': config.get('total_runs', 0) if config else 0,
                            'message': 'Stopped by user - Ready for new commands'
                        })
                        break
                    
                    print(f"\n[{datetime.now().strftime('%H:%M:%S')}] Sync cycle {run_num}/{config['total_runs']}")
                    
                    # Update status
                    save_status({
                        'running': True,
                        'completed': run_num - 1,
                        'total': config['total_runs'],
                        'current_run': run_num,
                        'message': f'Syncing data {run_num}/{config["total_runs"]}'
                    })
                    
                    # Sync files
                    print("  Syncing files...")
                    sync_success, sync_msg = sync_from_spartan(
                        config['remote_host'],
                        config['remote_directory'],
                        serial_number=config.get('serial_number')
                    )
                    print(f"  {sync_msg}")
                    
                    # Update status with result
                    save_status({
                        'running': True,
                        'completed': run_num,
                        'total': config['total_runs'],
                        'message': f'Synced {run_num}/{config["total_runs"]}',
                        'last_success': sync_success
                    })
                    
                    # Wait before next sync
                    if run_num < config['total_runs']:
                        print(f"  Waiting {wait_time} seconds before next sync...")
                        
                        for i in range(wait_time):
                            # Check for cancellation during wait
                            config = load_config()
                            if not config or not config.get('running'):
                                print(f"\n[{datetime.now().strftime('%H:%M:%S')}] Cancelled during wait")
                                save_status({
                                    'running': False,
                                    'completed': run_num,
                                    'total': config.get('total_runs', 0) if config else 0,
                                    'message': 'Stopped by user - Ready for new commands'
                                })
                                break
                            time.sleep(1)
                        else:
                            continue
                        break
                else:
                    # All syncs completed
                    print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ✓ All sync cycles completed!")
                    save_status({
                        'running': False,
                        'completed': config['total_runs'],
                        'total': config['total_runs'],
                        'message': 'Monitoring complete - Ready for new commands'
                    })
                    
                    # Mark as not running in config
                    if config:
                        config['running'] = False
                        with open(CONFIG_FILE, 'w') as f:
                            json.dump(config, f, indent=2)
            
            # Wait before checking again
            time.sleep(2)
            
        except KeyboardInterrupt:
            print(f"\n[{datetime.now().strftime('%H:%M:%S')}] Executor shutting down...")
            save_status({
                'running': False,
                'completed': 0,
                'total': 0,
                'message': 'Executor stopped'
            })
            break
        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Error: {str(e)}")
            time.sleep(5)

if __name__ == "__main__":
    main()
