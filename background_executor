#!/usr/bin/env python3
"""
Background executor script for auto-running commands on Spartan HPC
Run this separately: python background_executor.py
"""

import subprocess
import time
import json
import os
from datetime import datetime

CONFIG_FILE = "executor_config.json"
STATUS_FILE = "executor_status.json"

def load_config():
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return None

def save_status(status_data):
    """Save current status to file"""
    with open(STATUS_FILE, 'w') as f:
        json.dump(status_data, f, indent=2)

def sync_from_spartan(remote_host, remote_dir, local_dir="plots/"):
    """Execute rsync command and return success status"""
    check_command = (
        f"ssh {remote_host} "
        f"'ls -t {remote_dir}/*.png 2>/dev/null | head -n 1'"
    )
    
    try:
        check_result = subprocess.run(
            check_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        remote_file = check_result.stdout.strip()
        
        if not remote_file:
            return True, "No PNG files found on remote server"
        
        rsync_command = f"rsync -avz {remote_host}:{remote_file} {local_dir}"
        
        result = subprocess.run(
            rsync_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode == 0:
            return True, f"Synced: {os.path.basename(remote_file)}"
        else:
            return False, f"Rsync failed with code {result.returncode}"
        
    except Exception as e:
        return False, f"Sync error: {str(e)}"

def execute_command(remote_host, remote_dir, remote_command):
    """Execute command on remote server"""
    ssh_command = (
        f"ssh {remote_host} "
        f"'cd {remote_dir} && {remote_command}'"
    )
    
    try:
        result = subprocess.run(
            ssh_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        return result.returncode == 0, result.stdout, result.stderr
    except Exception as e:
        return False, "", str(e)

def main():
    print("Background executor started. Waiting for configuration...")
    
    while True:
        config = load_config()
        
        if config and config.get('running'):
            print(f"\nStarting auto-execute: {config['total_runs']} runs")
            
            for run_num in range(1, config['total_runs'] + 1):
                # Check if we should stop
                config = load_config()
                if not config or not config.get('running'):
                    print("Execution cancelled by user")
                    save_status({
                        'running': False,
                        'completed': run_num - 1,
                        'total': config['total_runs'],
                        'message': 'Cancelled by user'
                    })
                    break
                
                print(f"\n[{datetime.now().strftime('%H:%M:%S')}] Run {run_num}/{config['total_runs']}")
                
                # Update status
                save_status({
                    'running': True,
                    'completed': run_num - 1,
                    'total': config['total_runs'],
                    'current_run': run_num,
                    'message': f'Running {run_num}/{config["total_runs"]}'
                })
                
                # Sync files
                print("  Syncing files...")
                sync_success, sync_msg = sync_from_spartan(
                    config['remote_host'],
                    config['remote_directory']
                )
                print(f"  {sync_msg}")
                
                # Execute command
                print("  Executing command...")
                exec_success, stdout, stderr = execute_command(
                    config['remote_host'],
                    config['remote_directory'],
                    config['remote_command']
                )
                
                if exec_success:
                    print(f"  ✓ Run {run_num} completed successfully")
                else:
                    print(f"  ✗ Run {run_num} failed")
                    if stderr:
                        print(f"  Error: {stderr[:200]}")
                
                # Update status with result
                save_status({
                    'running': True,
                    'completed': run_num,
                    'total': config['total_runs'],
                    'message': f'Completed {run_num}/{config["total_runs"]}',
                    'last_success': exec_success
                })
                
                # Wait before next run (except for last run)
                if run_num < config['total_runs']:
                    wait_time = config.get('interval_seconds', 60)
                    print(f"  Waiting {wait_time} seconds...")
                    
                    for i in range(wait_time):
                        # Check for cancellation during wait
                        config = load_config()
                        if not config or not config.get('running'):
                            print("\nExecution cancelled during wait")
                            save_status({
                                'running': False,
                                'completed': run_num,
                                'total': config['total_runs'],
                                'message': 'Cancelled by user'
                            })
                            break
                        time.sleep(1)
                    else:
                        continue
                    break
            else:
                # All runs completed
                print(f"\n✓ All {config['total_runs']} runs completed!")
                save_status({
                    'running': False,
                    'completed': config['total_runs'],
                    'total': config['total_runs'],
                    'message': 'All runs completed successfully'
                })
                
                # Clear the config to stop
                config['running'] = False
                with open(CONFIG_FILE, 'w') as f:
                    json.dump(config, f, indent=2)
        
        # Wait before checking again
        time.sleep(2)

if __name__ == "__main__":
    main()
