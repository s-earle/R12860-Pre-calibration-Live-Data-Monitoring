import streamlit as st
from streamlit_autorefresh import st_autorefresh
import subprocess
import os
import time
import json
import threading
import signal
import sys


st.set_page_config(page_title="Rsync File Retriever", page_icon="üîÑ")


st.title("Live Data Monitoring")

st.write("Sync with Spartan HPC for processed charge result")

CONFIG_FILE = "executor_config.json"
STATUS_FILE = "executor_status.json"
EXECUTOR_PID_FILE = "executor_pid.txt"

# *---- Remove old data: --------------------------------------------------------------------------*
def cleanup_old_plots(directory, max_age_hours):
    """Delete data files older than max_age_hours"""
    if not os.path.exists(directory):
        return 0
    
    current_time = time.time()
    max_age_seconds = max_age_hours * 3600
    deleted_count = 0
    
    for filename in os.listdir(directory):
        if filename.endswith('.png'):
            file_path = os.path.join(directory, filename)
            file_age = current_time - os.path.getmtime(file_path)
            
            if file_age > max_age_seconds:
                try:
                    os.remove(file_path)
                    deleted_count += 1
                except Exception as e:
                    st.warning(f"Could not delete {filename}: {str(e)}")
    
    return deleted_count


def archive_plots_on_server(remote_host, remote_dir, archive_dir):
    """Move plots and text files from remote directory to archive directory"""
    # Create archive directory if it doesn't exist
    mkdir_command = f"ssh {remote_host} 'mkdir -p {archive_dir}'"
    
    try:
        subprocess.run(
            mkdir_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Move PNG and TXT files to archive
        move_command = (
            f"ssh {remote_host} "
            f"'mv {remote_dir}/*.png {remote_dir}/*.txt {archive_dir}/ 2>/dev/null || true'"
        )
        
        result = subprocess.run(
            move_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=60
        )
        
        return True, "Files archived successfully"
        
    except subprocess.TimeoutExpired:
        return False, "Archive operation timed out"
    except Exception as e:
        return False, f"Archive error: {str(e)}"

def flag_plots_on_server(remote_host, remote_dir, flag_dir):
    """Move plots and text files from remote directory to flagged directory"""
    # Create flag directory if it doesn't exist
    mkdir_command = f"ssh {remote_host} 'mkdir -p {flag_dir}'"
    
    try:
        subprocess.run(
            mkdir_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Move PNG and TXT files to flag directory
        move_command = (
            f"ssh {remote_host} "
            f"'mv {remote_dir}/*.png {remote_dir}/*.txt {flag_dir}/ 2>/dev/null || true'"
        )
        
        result = subprocess.run(
            move_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=60
        )
        
        return True, "Files flagged successfully"
        
    except subprocess.TimeoutExpired:
        return False, "Flag operation timed out"
    except Exception as e:
        return False, f"Flag error: {str(e)}"




# *---- Performing sync: --------------------------------------------------------------------------*
# |     Here we look to a remote server (currently Spartan at unimelb) and sync the data outputs   |
# |     from a specific directory. The code is written to use a directory I (S.Earle) made         |
# |     however this can be changed in the GUI or changed here in the backend code.                |
# |     We could as easily use sukap or just local                                                 |
# *------------------------------------------------------------------------------------------------*
def sync_from_spartan(remote_host, remote_dir, local_dir="plots/"):
    """Execute rsync command"""
    check_command = (
        f"ssh {remote_host} "
        f"'ls -t {remote_dir}/*.png 2>/dev/null | head -n 1'" # Looks for the most recent png file (plot of charge distribution) - here we can change what we sync with
    )
    
    try:
        check_result = subprocess.run(
            check_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        remote_file = check_result.stdout.strip()
        
        if not remote_file:
            st.info("No PNG files found on remote server yet")
            return True
        
        rsync_command = f"rsync -avz {remote_host}:{remote_file} {local_dir}" # Syncing command; remote_host and remote_file are defined below 
        
        result = subprocess.run(
            rsync_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        return result.returncode == 0
        
    except subprocess.TimeoutExpired:
        st.warning("‚ö†Ô∏è Sync operation timed out")
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Sync error: {str(e)}")
        return False

def load_status():
    """Load executor status from file"""
    if os.path.exists(STATUS_FILE):
        try:
            with open(STATUS_FILE, 'r') as f:
                return json.load(f)
        except:
            return None
    return None

def save_config(config):
    """Save configuration to file"""
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)

# *---- Background executor: ----------------------------------------------------------------------*
# |     This allows the GUI to be interfaced with meanwhile automating the data processing and     |
# |     sync functions.                                                                            |
# *------------------------------------------------------------------------------------------------*
def start_background_executor():
    """Start the background executor as a subprocess"""
    try:
        # Start the background executor
        process = subprocess.Popen(
            [sys.executable, "background_executor.py"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True
        )
        
        # Save the PID
        with open(EXECUTOR_PID_FILE, 'w') as f:
            f.write(str(process.pid))
        
        return True, process.pid
    except Exception as e:
        return False, str(e)

def check_executor_running():
    """Check if background executor is running"""
    if not os.path.exists(EXECUTOR_PID_FILE):
        return False
    
    try:
        with open(EXECUTOR_PID_FILE, 'r') as f:
            pid = int(f.read().strip())
        
        # Check if process is still running
        os.kill(pid, 0)
        return True
    except (OSError, ValueError):
        # Process doesn't exist or invalid PID
        if os.path.exists(EXECUTOR_PID_FILE):
            os.remove(EXECUTOR_PID_FILE)
        return False

def stop_background_executor():
    """Stop the background executor"""
    if not os.path.exists(EXECUTOR_PID_FILE):
        return True, "Executor not running"
    
    try:
        with open(EXECUTOR_PID_FILE, 'r') as f:
            pid = int(f.read().strip())
        
        # Terminate the process
        os.kill(pid, signal.SIGTERM)
        time.sleep(0.5)
        
        # Clean up PID file
        if os.path.exists(EXECUTOR_PID_FILE):
            os.remove(EXECUTOR_PID_FILE)
        
        return True, "Executor stopped"
    except Exception as e:
        return False, str(e)
    
# *---- Remote functions: -------------------------------------------------------------------------*
# |     Here we can change the remote server, and directory, and command that is executed on the   |
# |     server.                                                                                    |
# *------------------------------------------------------------------------------------------------*
if "remote_host" not in st.session_state:
    st.session_state.remote_host = "earles@spartan.hpc.unimelb.edu.au"

if "remote_directory" not in st.session_state:
    st.session_state.remote_directory = "/data/gpfs/projects/punim1378/earles/Precal_GUI"

if "remote_command" not in st.session_state:
    st.session_state.remote_command = "sbatch ./RUN.slurm" # This is the executing file on server. We can write anyone we want and then insert it here OR change it on the GUI. 

if "archive_directory" not in st.session_state:
    st.session_state.archive_directory = "/data/gpfs/projects/punim1378/earles/Precal_GUI/archive"

if "flag_directory" not in st.session_state:
    st.session_state.flag_directory = "/data/gpfs/projects/punim1378/earles/Precal_GUI/FLAG"


if "cleanup_time_hours" not in st.session_state:
    st.session_state.cleanup_time_hours = 24

if "selected_plot" not in st.session_state:
    st.session_state.selected_plot = None

# Automatic cleanup on page load
cleanup_old_plots("plots/", st.session_state.cleanup_time_hours)

# Check background executor status
status = load_status()
is_running = bool(status and status.get('running', False))
executor_alive = check_executor_running()

# Auto-refresh when background executor is running
if is_running:
    # Refresh every 5 seconds (5000 milliseconds)
    st_autorefresh(interval=5000, key="datarefresh") # We will want to change this to a longer period, aligning with the full scanning time

# Background Executor Status
st.sidebar.header("STEP 1: Background Executor")
if executor_alive:
    st.sidebar.success("‚úÖ Running")
else:
    st.sidebar.warning("‚ö†Ô∏è Not Running")

col_exec1, col_exec2 = st.sidebar.columns(2)
with col_exec1:
    if st.button("‚ñ∂Ô∏è Start", disabled=executor_alive, use_container_width=True):
        success, result = start_background_executor()
        if success:
            st.success(f"‚úÖ Executor started (PID: {result})")
            time.sleep(1)
            st.rerun()
        else:
            st.error(f"‚ùå Failed to start: {result}")

with col_exec2:
    if st.button("‚èπÔ∏è Stop", disabled=not executor_alive, use_container_width=True):
        success, msg = stop_background_executor()
        if success:
            st.success(f"‚úÖ {msg}")
            time.sleep(1)
            st.rerun()
        else:
            st.error(f"‚ùå Failed: {msg}")

if st.sidebar.button("Reset All", type="secondary", use_container_width=True):
    # Stop executor
    stop_background_executor()
    
    # Clean up all status files
    for file in [CONFIG_FILE, STATUS_FILE, EXECUTOR_PID_FILE]:
        if os.path.exists(file):
            os.remove(file)
    
    st.sidebar.success("Reset complete!")
    time.sleep(1)
    st.rerun()

st.sidebar.divider()

# Show configuration
with st.expander("STEP 2: Check Remote Execution Configuration"):
    st.session_state.remote_host = st.text_input(
        "Remote Host",
        value=st.session_state.remote_host
    )
    st.session_state.remote_directory = st.text_input(
        "Remote Directory",
        value=st.session_state.remote_directory
    )
    st.session_state.remote_command = st.text_input(
        "Command to Execute",
        value=st.session_state.remote_command
    )


with st.expander("STEP 3: Archive or Flag Data Files on Server"):
    st.session_state.archive_directory = st.text_input(
        "Archive Directory on Server:",
        value=st.session_state.archive_directory,
        help="Remote directory where normal data files will be moved to"
    )
    
    st.session_state.flag_directory = st.text_input(
        "Flag Directory on Server:",
        value=st.session_state.flag_directory,
        help="Remote directory where abnormal/flagged data files will be moved to"
    )
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("Archive Server Data", type="secondary", use_container_width=True):
            st.info("Archiving data on server...")
            success, message = archive_plots_on_server(
                st.session_state.remote_host,
                st.session_state.remote_directory,
                st.session_state.archive_directory
            )
            
            if success:
                st.success(f"‚úÖ {message}")
            else:
                st.error(f"‚ùå {message}")
    
    with col2:
        if st.button("Flag Server Data", type="primary", use_container_width=True):
            st.info("Flagging data on server...")
            success, message = flag_plots_on_server(
                st.session_state.remote_host,
                st.session_state.remote_directory,
                st.session_state.flag_directory
            )
            
            if success:
                st.success(f"‚úÖ {message}")
            else:
                st.error(f"‚ùå {message}")
    
    st.caption("Archive: Move normal data files to archive directory | Flag: Move abnormal data files to flag directory")
    
    st.caption("This will move all data files from the remote directory to the archive directory on the server.")
    st.markdown("IF A SCANNED DATA POINT IS FLAGGED AS ABNORMAL - PLEASE CHANGE DIRECTORY TO:  above/directory/GUI/FLAG ")
with st.expander("STEP 4: Configure Local Auto-Cleanup -- Execute before starting Scan"):
    cleanup_hours = st.number_input(
        "Delete data files older than (hours)",
        min_value=1,
        max_value=720,
        value=st.session_state.cleanup_time_hours,
        step=1,
        help="Data files on local machine older than this will be automatically deleted when user clicks 'Clear Old Data Now' "
    )
    st.session_state.cleanup_time_hours = cleanup_hours
    
    if st.button("Clear Old Data Now"):
        deleted = cleanup_old_plots("plots/", st.session_state.cleanup_time_hours)
        if deleted > 0:
            st.success(f"Deleted {deleted} old data file(s)")
        else:
            st.info("No old files to delete")
    
    if st.button("Clear ALL Data Now"):
        if os.path.exists("plots/"):
            count = 0
            for f in os.listdir("plots/"):
                if f.endswith('.png'):
                    try:
                        os.remove(os.path.join("plots/", f))
                        count += 1
                    except Exception as e:
                        st.error(f"Error deleting {f}: {str(e)}")
            st.success(f"Deleted all {count} plot files")
        else:
            st.warning("Data directory doesn't exist")

if is_running:
    st.info(f"Background executor running: {status.get('message', 'Processing...')}")
    if status.get('total'):
        progress = status.get('completed', 0) / status['total']
        st.progress(progress)
        st.write(f"Completed: {status.get('completed', 0)}/{status['total']}")


if st.button("STEP 5: Start Auto-Execute (21 runs)", type="primary", disabled=is_running or not executor_alive, use_container_width=True):
    config = {
        'running': True,
        'remote_host': st.session_state.remote_host,
        'remote_directory': st.session_state.remote_directory,
        'remote_command': st.session_state.remote_command,
        'total_runs': 21, # Change this depending on no. of scan points
        'interval_seconds': 60 # this is a testing number (60s) needs to be changed to match full scanning time
    }
    save_config(config)
    st.success("Auto-execute started!")
    time.sleep(1)
    st.rerun()
st.caption(
            "This will autmatically process data on the server, and sync with that data. There is a delay between finishing a scan point and the data coming through."
        )

if st.button("Stop Auto-Execute", type="primary", disabled=not is_running, use_container_width=True):
    # Just stop the auto-execute, keep executor running
    if os.path.exists(CONFIG_FILE):
        config = load_status()
        if config:
            config['running'] = False
            save_config(config)
    
    if os.path.exists(STATUS_FILE):
        status = load_status()
        if status:
            status['running'] = False
            status['message'] = 'Stopped by user'
            with open(STATUS_FILE, 'w') as f:
                json.dump(status, f, indent=2)
    
    st.success("Auto-execute stopped (executor still running)")
    time.sleep(1)
    st.rerun()

if st.button("Execute on Server Once (For ONE scan point)", type="secondary", disabled=is_running or not executor_alive, use_container_width=True):
    st.info("Syncing files from Server...")
    sync_from_spartan(st.session_state.remote_host, st.session_state.remote_directory)
    
    st.info("Executing command on Server...")
    
    ssh_command = (
        f"ssh {st.session_state.remote_host} "
        f"'cd {st.session_state.remote_directory} && {st.session_state.remote_command}'"
    )
    
    st.code(ssh_command, language="bash")
    
    try:
        result = subprocess.run(
            ssh_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode == 0:
            st.success("Command executed successfully!")
        else:
            st.warning("Command completed with errors")
        
        if result.stdout:
            st.subheader("Output:")
            st.code(result.stdout, language="bash")
        
        if result.stderr:
            st.subheader("Errors/Messages:")
            st.code(result.stderr, language="bash")
        
        st.info(f"Return code: {result.returncode}")
            
    except subprocess.TimeoutExpired:
        st.error("‚ùå Command timed out (exceeded 2 minutes)")
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")


# Show refresh controls when running
if is_running:
    st.info("Page auto-refreshes every 5 seconds. All buttons remain clickable!")
    if st.button("Refresh Now", use_container_width=True):
        st.rerun()

if st.button("Manual Sync", type="secondary", use_container_width=True):
    st.info("Executing sync... This may take a moment.")
    
    if sync_from_spartan(st.session_state.remote_host, st.session_state.remote_directory):
        st.success("Sync completed successfully!")
    else:
        st.warning("‚ö†Ô∏è Sync completed with issues")
    
    plots_dir = "plots/"
    if os.path.exists(plots_dir):
        png_files = [f for f in os.listdir(plots_dir) if f.endswith('.png')]
        if png_files:
            latest_file = max([os.path.join(plots_dir, f) for f in png_files], key=os.path.getmtime)
            st.subheader("Latest Retrieved File:")
            st.image(latest_file, caption=os.path.basename(latest_file))
st.caption(
            "This will only sync the most recent data point."
        )
st.divider()
st.subheader("Recent Scan Data")
st.caption(
    "Shows the most recent scan results synced from the server. "
    "Data will lag slightly behind acquisition. "
    "Clicking View will also clear old data."
)

plots_dir = "plots"
N_COLS = 4
N_ROWS = 5
MAX_PLOTS = N_COLS * N_ROWS + 1

if os.path.exists(plots_dir):
    png_files = [
        os.path.join(plots_dir, f)
        for f in os.listdir(plots_dir)
        if f.endswith(".png")
    ]
else:
    png_files = []

if not os.path.exists(plots_dir):
    st.warning(f"Directory does not exist: {plots_dir}")

png_files = sorted(png_files, key=os.path.getmtime, reverse=True)
png_files = png_files[:MAX_PLOTS]

def get_coordinate_label(slot):
    if slot == 0:
        return "[0, 0]"
    else:
        row_num = ((slot - 1) // 4) + 1
        col_num = (slot - 1) % 4
        theta = row_num * 10
        phi = col_num * 90
        return f"[{theta}, {phi}]"

slot = 0
num_files = len(png_files)

st.markdown("""
<style>
    .grid-button {
        background-color: #28a745;
        color: white;
        padding: 20px 10px;
        text-align: center;
        border-radius: 5px;
        font-weight: bold;
        font-size: 14px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.3s;
        min-height: 100px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .grid-button:hover {
        border-color: #0066cc;
        opacity: 0.9;
        background-color: #218838;
    }
    .no-data-box {
        background-color: #ffc107;
        color: #333;
        padding: 20px 10px;
        text-align: center;
        border-radius: 5px;
        font-weight: bold;
        font-size: 14px;
        border: 1px solid #e0a800;
        min-height: 100px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .coordinate-label {
        font-size: 12px;
        margin-top: 5px;
        opacity: 0.9;
        font-weight: bold;
    }
</style>
""", unsafe_allow_html=True)

# First row - single [0,0] button centered
col1, col2, col3 = st.columns([1, 2, 1])
with col2:
    file_idx = num_files - 1 - slot
    coord_label = get_coordinate_label(slot)
    
    if 0 <= file_idx < num_files:
        img_path = png_files[file_idx]
        
        st.markdown(
            f"""
            <div class="grid-button">
                <div>Healthy</div>
                <div class="coordinate-label">{coord_label}</div>
            </div>
            """,
            unsafe_allow_html=True
        )
        
        if st.button("View", key=f"view_{slot}", use_container_width=True):
            st.session_state.selected_plot = img_path
    else:
        st.markdown(
            f"""
            <div class="no-data-box">
                <div>‚ö† No Data</div>
                <div class="coordinate-label">{coord_label}</div>
            </div>
            """,
            unsafe_allow_html=True
        )

slot += 1

# Remaining rows - 4 columns each
for row in range(N_ROWS):
    cols = st.columns(N_COLS)
    for col in cols:
        file_idx = num_files - 1 - slot
        coord_label = get_coordinate_label(slot)

        with col:
            if 0 <= file_idx < num_files:
                img_path = png_files[file_idx]
                
                st.markdown(
                    f"""
                    <div class="grid-button">
                        <div>Healthy</div>
                        <div class="coordinate-label">{coord_label}</div>
                    </div>
                    """,
                    unsafe_allow_html=True
                )
                
                if st.button("View", key=f"view_{slot}", use_container_width=True):
                    st.session_state.selected_plot = img_path
                
            else:
                st.markdown(
                    f"""
                    <div class="no-data-box">
                        <div>‚ö† No Data</div>
                        <div class="coordinate-label">{coord_label}</div>
                    </div>
                    """,
                    unsafe_allow_html=True
                )

        slot += 1

if st.session_state.selected_plot:
    st.divider()
    st.subheader("Selected Data")
    st.image(
        st.session_state.selected_plot,
        use_container_width=True,
        caption=os.path.basename(st.session_state.selected_plot)
    )

st.divider()
st.subheader("Data Files in Local Directory")

plots_dir = "plots/"
if os.path.exists(plots_dir):
    png_files = sorted([f for f in os.listdir(plots_dir) if f.endswith('.png')], 
                       key=lambda x: os.path.getmtime(os.path.join(plots_dir, x)), 
                       reverse=True)
    if png_files:
        st.write(f"Found {len(png_files)} data file(s):")
        for f in png_files:
            st.text(f)
    else:
        st.info("No files found in the data directory yet.")
else:
    st.warning(f"Directory does not exist: {plots_dir}")
