import streamlit as st
from streamlit_autorefresh import st_autorefresh
import subprocess
import os
import time
import json
import threading
import signal
import sys

# Set page title
st.set_page_config(page_title="Rsync File Retriever", page_icon="üîÑ")

# App title
st.title("Live Data Monitoring")

st.write("Sync with Spartan HPC for processed charge result")

CONFIG_FILE = "executor_config.json"
STATUS_FILE = "executor_status.json"
EXECUTOR_PID_FILE = "executor_pid.txt"

# Function to clean up old files
def cleanup_old_plots(directory, max_age_hours):
    """Delete plot files older than max_age_hours"""
    if not os.path.exists(directory):
        return 0
    
    current_time = time.time()
    max_age_seconds = max_age_hours * 3600
    deleted_count = 0
    
    for filename in os.listdir(directory):
        if filename.endswith('.png'):
            file_path = os.path.join(directory, filename)
            file_age = current_time - os.path.getmtime(file_path)
            
            if file_age > max_age_seconds:
                try:
                    os.remove(file_path)
                    deleted_count += 1
                except Exception as e:
                    st.warning(f"Could not delete {filename}: {str(e)}")
    
    return deleted_count

# Function to perform sync with better error handling
def sync_from_spartan(remote_host, remote_dir, local_dir="plots/"):
    """Execute rsync command and return success status"""
    check_command = (
        f"ssh {remote_host} "
        f"'ls -t {remote_dir}/*.png 2>/dev/null | head -n 1'"
    )
    
    try:
        check_result = subprocess.run(
            check_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        remote_file = check_result.stdout.strip()
        
        if not remote_file:
            st.info("No PNG files found on remote server yet")
            return True
        
        rsync_command = f"rsync -avz {remote_host}:{remote_file} {local_dir}"
        
        result = subprocess.run(
            rsync_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        return result.returncode == 0
        
    except subprocess.TimeoutExpired:
        st.warning("‚ö†Ô∏è Sync operation timed out")
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Sync error: {str(e)}")
        return False

def load_status():
    """Load executor status from file"""
    if os.path.exists(STATUS_FILE):
        try:
            with open(STATUS_FILE, 'r') as f:
                return json.load(f)
        except:
            return None
    return None

def save_config(config):
    """Save configuration to file"""
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)

def start_background_executor():
    """Start the background executor as a subprocess"""
    try:
        # Start the background executor
        process = subprocess.Popen(
            [sys.executable, "background_executor.py"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True
        )
        
        # Save the PID
        with open(EXECUTOR_PID_FILE, 'w') as f:
            f.write(str(process.pid))
        
        return True, process.pid
    except Exception as e:
        return False, str(e)

def check_executor_running():
    """Check if background executor is running"""
    if not os.path.exists(EXECUTOR_PID_FILE):
        return False
    
    try:
        with open(EXECUTOR_PID_FILE, 'r') as f:
            pid = int(f.read().strip())
        
        # Check if process is still running
        os.kill(pid, 0)
        return True
    except (OSError, ValueError):
        # Process doesn't exist or invalid PID
        if os.path.exists(EXECUTOR_PID_FILE):
            os.remove(EXECUTOR_PID_FILE)
        return False

def stop_background_executor():
    """Stop the background executor"""
    if not os.path.exists(EXECUTOR_PID_FILE):
        return True, "Executor not running"
    
    try:
        with open(EXECUTOR_PID_FILE, 'r') as f:
            pid = int(f.read().strip())
        
        # Terminate the process
        os.kill(pid, signal.SIGTERM)
        time.sleep(0.5)
        
        # Clean up PID file
        if os.path.exists(EXECUTOR_PID_FILE):
            os.remove(EXECUTOR_PID_FILE)
        
        return True, "Executor stopped"
    except Exception as e:
        return False, str(e)

if "remote_host" not in st.session_state:
    st.session_state.remote_host = "earles@spartan.hpc.unimelb.edu.au"

if "remote_directory" not in st.session_state:
    st.session_state.remote_directory = "/data/gpfs/projects/punim1378/earles/Precal_GUI"

if "remote_command" not in st.session_state:
    st.session_state.remote_command = "sbatch ./RUN.slurm"

if "cleanup_time_hours" not in st.session_state:
    st.session_state.cleanup_time_hours = 24

if "selected_plot" not in st.session_state:
    st.session_state.selected_plot = None

# Automatic cleanup on page load
cleanup_old_plots("plots/", st.session_state.cleanup_time_hours)

# Check background executor status
status = load_status()
is_running = bool(status and status.get('running', False))
executor_alive = check_executor_running()

# Auto-refresh when background executor is running
if is_running:
    # Refresh every 5 seconds (5000 milliseconds)
    st_autorefresh(interval=5000, key="datarefresh")

# Background Executor Status
st.sidebar.header("Background Executor")
if executor_alive:
    st.sidebar.success("‚úÖ Running")
else:
    st.sidebar.warning("‚ö†Ô∏è Not Running")

col_exec1, col_exec2 = st.sidebar.columns(2)
with col_exec1:
    if st.button("‚ñ∂Ô∏è Start", disabled=executor_alive, use_container_width=True):
        success, result = start_background_executor()
        if success:
            st.success(f"‚úÖ Executor started (PID: {result})")
            time.sleep(1)
            st.rerun()
        else:
            st.error(f"‚ùå Failed to start: {result}")

with col_exec2:
    if st.button("‚èπÔ∏è Stop", disabled=not executor_alive, use_container_width=True):
        success, msg = stop_background_executor()
        if success:
            st.success(f"‚úÖ {msg}")
            time.sleep(1)
            st.rerun()
        else:
            st.error(f"‚ùå Failed: {msg}")

if st.sidebar.button("Reset All", type="secondary", use_container_width=True):
    # Stop executor
    stop_background_executor()
    
    # Clean up all status files
    for file in [CONFIG_FILE, STATUS_FILE, EXECUTOR_PID_FILE]:
        if os.path.exists(file):
            os.remove(file)
    
    st.sidebar.success("Reset complete!")
    time.sleep(1)
    st.rerun()

st.sidebar.divider()

# Show configuration
with st.expander("Configure Remote Execution"):
    st.session_state.remote_host = st.text_input(
        "Remote Host",
        value=st.session_state.remote_host
    )
    st.session_state.remote_directory = st.text_input(
        "Remote Directory",
        value=st.session_state.remote_directory
    )
    st.session_state.remote_command = st.text_input(
        "Command to Execute",
        value=st.session_state.remote_command
    )

with st.expander("Configure Auto-Cleanup"):
    cleanup_hours = st.number_input(
        "Delete plot files older than (hours)",
        min_value=1,
        max_value=720,
        value=st.session_state.cleanup_time_hours,
        step=1,
        help="Plot files older than this will be automatically deleted"
    )
    st.session_state.cleanup_time_hours = cleanup_hours
    
    if st.button("Clean Up Now"):
        deleted = cleanup_old_plots("plots/", st.session_state.cleanup_time_hours)
        if deleted > 0:
            st.success(f"Deleted {deleted} old plot file(s)")
        else:
            st.info("No old files to delete")
    
    if st.button("Clear All Plots"):
        if os.path.exists("plots/"):
            count = 0
            for f in os.listdir("plots/"):
                if f.endswith('.png'):
                    try:
                        os.remove(os.path.join("plots/", f))
                        count += 1
                    except Exception as e:
                        st.error(f"Error deleting {f}: {str(e)}")
            st.success(f"Deleted all {count} plot files")
        else:
            st.warning("Plots directory doesn't exist")

if is_running:
    st.info(f"Background executor running: {status.get('message', 'Processing...')}")
    if status.get('total'):
        progress = status.get('completed', 0) / status['total']
        st.progress(progress)
        st.write(f"Completed: {status.get('completed', 0)}/{status['total']}")


if st.button("Start Auto-Execute (21 runs)", type="primary", disabled=is_running or not executor_alive, use_container_width=True):
    config = {
        'running': True,
        'remote_host': st.session_state.remote_host,
        'remote_directory': st.session_state.remote_directory,
        'remote_command': st.session_state.remote_command,
        'total_runs': 21,
        'interval_seconds': 60
    }
    save_config(config)
    st.success("Auto-execute started!")
    time.sleep(1)
    st.rerun()

if st.button("Stop Auto-Execute", type="primary", disabled=not is_running, use_container_width=True):
    # Just stop the auto-execute, keep executor running
    if os.path.exists(CONFIG_FILE):
        config = load_status()
        if config:
            config['running'] = False
            save_config(config)
    
    if os.path.exists(STATUS_FILE):
        status = load_status()
        if status:
            status['running'] = False
            status['message'] = 'Stopped by user'
            with open(STATUS_FILE, 'w') as f:
                json.dump(status, f, indent=2)
    
    st.success("Auto-execute stopped (executor still running)")
    time.sleep(1)
    st.rerun()

if st.button("Execute on Spartan Once", type="secondary", disabled=is_running or not executor_alive, use_container_width=True):
    st.info("Syncing files from Spartan...")
    sync_from_spartan(st.session_state.remote_host, st.session_state.remote_directory)
    
    st.info("Executing command on Spartan...")
    
    ssh_command = (
        f"ssh {st.session_state.remote_host} "
        f"'cd {st.session_state.remote_directory} && {st.session_state.remote_command}'"
    )
    
    st.code(ssh_command, language="bash")
    
    try:
        result = subprocess.run(
            ssh_command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode == 0:
            st.success("Command executed successfully!")
        else:
            st.warning("Command completed with errors")
        
        if result.stdout:
            st.subheader("Output:")
            st.code(result.stdout, language="bash")
        
        if result.stderr:
            st.subheader("Errors/Messages:")
            st.code(result.stderr, language="bash")
        
        st.info(f"Return code: {result.returncode}")
            
    except subprocess.TimeoutExpired:
        st.error("‚ùå Command timed out (exceeded 2 minutes)")
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")


# Show refresh controls when running
if is_running:
    st.info("Page auto-refreshes every 5 seconds. All buttons remain clickable!")
    if st.button("Refresh Now", use_container_width=True):
        st.rerun()

if st.button("Sync", type="primary"):
    st.info("Executing sync... This may take a moment.")
    
    if sync_from_spartan(st.session_state.remote_host, st.session_state.remote_directory):
        st.success("Sync completed successfully!")
    else:
        st.warning("‚ö†Ô∏è Sync completed with issues")
    
    plots_dir = "plots/"
    if os.path.exists(plots_dir):
        png_files = [f for f in os.listdir(plots_dir) if f.endswith('.png')]
        if png_files:
            latest_file = max([os.path.join(plots_dir, f) for f in png_files], key=os.path.getmtime)
            st.subheader("Latest Retrieved File:")
            st.image(latest_file, caption=os.path.basename(latest_file))

st.divider()
st.subheader("Recent Scan Data")

plots_dir = "plots"
N_COLS = 4
N_ROWS = 5
MAX_PLOTS = N_COLS * N_ROWS + 1

if os.path.exists(plots_dir):
    png_files = [
        os.path.join(plots_dir, f)
        for f in os.listdir(plots_dir)
        if f.endswith(".png")
    ]
else:
    png_files = []

if not os.path.exists(plots_dir):
    st.warning(f"Directory does not exist: {plots_dir}")

png_files = sorted(png_files, key=os.path.getmtime, reverse=True)
png_files = png_files[:MAX_PLOTS]

def get_coordinate_label(slot):
    if slot == 0:
        return "[0, 0]"
    else:
        row_num = ((slot - 1) // 4) + 1
        col_num = (slot - 1) % 4
        theta = row_num * 10
        phi = col_num * 90
        return f"[{theta}, {phi}]"

slot = 0
num_files = len(png_files)

st.markdown("""
<style>
    .grid-button {
        background-color: #28a745;
        color: white;
        padding: 20px 10px;
        text-align: center;
        border-radius: 5px;
        font-weight: bold;
        font-size: 14px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.3s;
        min-height: 100px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .grid-button:hover {
        border-color: #0066cc;
        opacity: 0.9;
        background-color: #218838;
    }
    .no-data-box {
        background-color: #ffc107;
        color: #333;
        padding: 20px 10px;
        text-align: center;
        border-radius: 5px;
        font-weight: bold;
        font-size: 14px;
        border: 1px solid #e0a800;
        min-height: 100px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .coordinate-label {
        font-size: 12px;
        margin-top: 5px;
        opacity: 0.9;
        font-weight: bold;
    }
</style>
""", unsafe_allow_html=True)

# First row - single [0,0] button centered
col1, col2, col3 = st.columns([1, 2, 1])
with col2:
    file_idx = num_files - 1 - slot
    coord_label = get_coordinate_label(slot)
    
    if 0 <= file_idx < num_files:
        img_path = png_files[file_idx]
        
        st.markdown(
            f"""
            <div class="grid-button">
                <div>Healthy</div>
                <div class="coordinate-label">{coord_label}</div>
            </div>
            """,
            unsafe_allow_html=True
        )
        
        if st.button("View", key=f"view_{slot}", use_container_width=True):
            st.session_state.selected_plot = img_path
    else:
        st.markdown(
            f"""
            <div class="no-data-box">
                <div>‚ö† No Data</div>
                <div class="coordinate-label">{coord_label}</div>
            </div>
            """,
            unsafe_allow_html=True
        )

slot += 1

# Remaining rows - 4 columns each
for row in range(N_ROWS):
    cols = st.columns(N_COLS)
    for col in cols:
        file_idx = num_files - 1 - slot
        coord_label = get_coordinate_label(slot)

        with col:
            if 0 <= file_idx < num_files:
                img_path = png_files[file_idx]
                
                st.markdown(
                    f"""
                    <div class="grid-button">
                        <div>Healthy</div>
                        <div class="coordinate-label">{coord_label}</div>
                    </div>
                    """,
                    unsafe_allow_html=True
                )
                
                if st.button("View", key=f"view_{slot}", use_container_width=True):
                    st.session_state.selected_plot = img_path
                
            else:
                st.markdown(
                    f"""
                    <div class="no-data-box">
                        <div>‚ö† No Data</div>
                        <div class="coordinate-label">{coord_label}</div>
                    </div>
                    """,
                    unsafe_allow_html=True
                )

        slot += 1

if st.session_state.selected_plot:
    st.divider()
    st.subheader("Selected Data")
    st.image(
        st.session_state.selected_plot,
        use_container_width=True,
        caption=os.path.basename(st.session_state.selected_plot)
    )

st.divider()
st.subheader("Files in Local Plots Directory")

plots_dir = "plots/"
if os.path.exists(plots_dir):
    png_files = sorted([f for f in os.listdir(plots_dir) if f.endswith('.png')], 
                       key=lambda x: os.path.getmtime(os.path.join(plots_dir, x)), 
                       reverse=True)
    if png_files:
        st.write(f"Found {len(png_files)} PNG file(s):")
        for f in png_files:
            st.text(f)
    else:
        st.info("No files found in the plots directory yet.")
else:
    st.warning(f"Directory does not exist: {plots_dir}")
